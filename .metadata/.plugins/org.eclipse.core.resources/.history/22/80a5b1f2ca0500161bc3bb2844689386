package graph;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;

/**
 * Utility class of methods for graphs.
 * @author zalan0
 *
 * Class containing methods to manipulate graphs.
 */
public class Graphs {
	
//	Graph graph;
//	
//	public Graphs(Graph g) {
//		graph = g;
//	}
	
	/**
	 * Breadth First Search implementation that produces a pairing of nodes
	 * that can be reversed to find a shortest route.
	 * 
	 * @param start
	 * @param goal
	 * @return
	 */
	public static HashMap<Vertex, Vertex> BFS(Vertex start, Vertex goal) {
//		ArrayList<Vertex> path = new ArrayList<Vertex>();
		
		// initialize queue, visited, and parent
		Queue<Vertex> queue = new LinkedList<Vertex>();
		HashSet<Vertex> visited = new HashSet<Vertex>();
		HashMap<Vertex, Vertex> parent = new HashMap<Vertex, Vertex>();
		
		// enqueue start onto queue and add to visited
		queue.add(start);
		visited.add(start);
		
		//while queue is not empty, do stuff...
		while(!queue.isEmpty()) {
			//dequeue node curr from front of queue
			Vertex curr = queue.poll();
			
			// if curr is goal then return parent map
			if(curr.equals(goal)) return parent;
			
			// for each of curr's neighbors, n, not in visited set
			Vertex[] neighbors = curr.getNeighbors();
			for(Vertex n: neighbors) {
				if(!visited.contains(n)) {
					// add n to visited set
					visited.add(n);
					
					//add curr as n's parent in parent
					parent.put(n, curr);
					
					// engueue n onto queue
					queue.add(n);
				}
			}
		}
		return null;
	}
	
	/**
	 * An implementation of BFS that returns the number of all possible shortest
	 * routes from start to goal.
	 * 
	 * @param start Vertex to start the search
	 * @return An ArrayList of HashSets of Vertices that show distance from start
	 * by their index within the ArrayList
	 */
	public static ArrayList<HashSet<Vertex>> shortesRoutesBFS (Vertex start) {
		// TODO implement BFS so that the level (distance from start is tracked
		// This should be done as the neighbors are being visited.
		
		// initialize queue, visited, and levels array
		ArrayList<HashSet<Vertex>> levels = new ArrayList<HashSet<Vertex>>();
		Queue<Vertex> currentLevel = new LinkedList<Vertex>();
		Queue<Vertex> nextLevel = new LinkedList<Vertex>();
		HashSet<Vertex> visited = new HashSet<Vertex>();
		
		// enqueue start onto queue and add to visited
		currentLevel.add(start);
		visited.add(start);
		
//		HashSet<Vertex> tempSet = new HashSet<Vertex>();
//		tempSet.add(start);
		levels.add(new HashSet<Vertex>(Arrays.asList(start));
		
		//while queue is not empty, do stuff...
		while(!currentLevel.isEmpty()) {
			//dequeue node curr from front of queue and increment level
			Vertex curr = currentLevel.poll();
			
			// for each of curr's neighbors, n, not in visited set
			Vertex[] neighbors = curr.getNeighbors();
			for(Vertex n: neighbors) {
				
				if(!visited.contains(n)) {
					
					// add n to visited set
					visited.add(n);
					
					// engueue n onto queue
					nextLevel.add(n);
				}
				
			}
			if(currentLevel.isEmpty()) {
				if(!nextLevel.isEmpty()) 
					levels.add(new HashSet<Vertex>(nextLevel));
				currentLevel.addAll(nextLevel);
				nextLevel = new LinkedList<Vertex>();
			}
		}
		return levels;
	}
}
